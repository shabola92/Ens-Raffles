"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkdapp"] = self["webpackChunkdapp"] || []).push([["batchWrappers-mjs"],{

/***/ "./node_modules/@ensdomains/ensjs/dist/esm/functions/batchWrappers.mjs":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ensdomains/ensjs/dist/esm/functions/batchWrappers.mjs ***!
  \*****************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   multicallWrapper: () => (/* binding */ multicallWrapper),\n/* harmony export */   resolverMulticallWrapper: () => (/* binding */ resolverMulticallWrapper),\n/* harmony export */   universalWrapper: () => (/* binding */ universalWrapper)\n/* harmony export */ });\n/* harmony import */ var _utils_ccip_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ccip.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/ccip.mjs\");\n/* harmony import */ var _utils_hexEncodedName_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/hexEncodedName.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs\");\n// src/functions/batchWrappers.ts\n\n\nvar universalWrapper = {\n  raw: async ({ contracts }, name, data) => {\n    const universalResolver = await contracts?.getUniversalResolver();\n    return {\n      to: universalResolver.address,\n      data: universalResolver.interface.encodeFunctionData(\n        \"resolve(bytes,bytes)\",\n        [(0,_utils_hexEncodedName_mjs__WEBPACK_IMPORTED_MODULE_1__.hexEncodeName)(name), data]\n      )\n    };\n  },\n  decode: async ({ contracts }, data) => {\n    const universalResolver = await contracts?.getUniversalResolver();\n    const response = universalResolver.interface.decodeFunctionResult(\n      \"resolve(bytes,bytes)\",\n      data\n    );\n    if (!response || !response[0]) {\n      return;\n    }\n    return { data: response[0], resolver: response[1] };\n  }\n};\nvar resolverMulticallWrapper = {\n  raw: async ({ contracts }, data) => {\n    const publicResolver = await contracts?.getPublicResolver();\n    const formattedDataArr = data.map((item) => item.data);\n    return {\n      to: publicResolver.address,\n      data: publicResolver.interface.encodeFunctionData(\"multicall\", [\n        formattedDataArr\n      ])\n    };\n  },\n  decode: async ({ contracts }, data) => {\n    const publicResolver = await contracts?.getPublicResolver();\n    const response = publicResolver.interface.decodeFunctionResult(\n      \"multicall\",\n      data\n    );\n    if (!response) {\n      return;\n    }\n    return response;\n  }\n};\nvar multicallWrapper = {\n  async raw({ contracts }, transactions, requireSuccess = false) {\n    const multicall = await contracts?.getMulticall();\n    return {\n      to: multicall.address,\n      data: multicall.interface.encodeFunctionData(\"tryAggregate\", [\n        requireSuccess,\n        transactions.map((tx) => ({\n          target: tx.to,\n          callData: tx.data\n        }))\n      ])\n    };\n  },\n  async decode({ contracts, provider }, data, transactions) {\n    if (!data)\n      return;\n    const multicall = await contracts?.getMulticall();\n    try {\n      const [result] = multicall.interface.decodeFunctionResult(\n        \"tryAggregate\",\n        data\n      );\n      const ccipChecked = await Promise.all(\n        result.map(\n          async ([success, returnData], i) => {\n            let newArr = [success, returnData];\n            if (!success && returnData.startsWith(\"0x556f1830\")) {\n              try {\n                const newData = await (0,_utils_ccip_mjs__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(\n                  provider,\n                  transactions[i],\n                  returnData\n                );\n                if (newData) {\n                  newArr = [true, newData];\n                }\n              } catch {\n              }\n            }\n            return {\n              ...newArr,\n              success: newArr[0],\n              returnData: newArr[1]\n            };\n          }\n        )\n      );\n      return ccipChecked;\n    } catch (e) {\n      console.error(e);\n      return;\n    }\n  }\n};\n\n\n\n//# sourceURL=webpack://dapp/./node_modules/@ensdomains/ensjs/dist/esm/functions/batchWrappers.mjs?");

/***/ }),

/***/ "./node_modules/@ensdomains/ensjs/dist/esm/utils/ccip.mjs":
/*!****************************************************************!*\
  !*** ./node_modules/@ensdomains/ensjs/dist/esm/utils/ccip.mjs ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ccip_default)\n/* harmony export */ });\n/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ \"./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ \"./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ \"./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n// src/utils/ccip.ts\n\n\n\nfunction bytesPad(value) {\n  if (value.length % 32 === 0) {\n    return value;\n  }\n  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n  result.set(value);\n  return result;\n}\nfunction numPad(value) {\n  const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(value);\n  if (result.length > 32) {\n    throw new Error(\"internal; should not happen\");\n  }\n  const padded = new Uint8Array(32);\n  padded.set(result, 32 - result.length);\n  return padded;\n}\nfunction encodeBytes(datas) {\n  const result = [];\n  let byteCount = 0;\n  for (let i = 0; i < datas.length; i += 1) {\n    result.push(new Uint8Array(0));\n    byteCount += 32;\n  }\n  for (let i = 0; i < datas.length; i += 1) {\n    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(datas[i]);\n    result[i] = numPad(byteCount);\n    result.push(numPad(data.length));\n    result.push(bytesPad(data));\n    byteCount += 32 + Math.ceil(data.length / 32) * 32;\n  }\n  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexConcat)(result);\n}\nfunction _parseBytes(result, start) {\n  if (result === \"0x\") {\n    return null;\n  }\n  const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(\n    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(result, start, start + 32)\n  ).toNumber();\n  const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(\n    (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(result, offset, offset + 32)\n  ).toNumber();\n  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(result, offset + 32, offset + 32 + length);\n}\nfunction _parseString(result, start) {\n  try {\n    const bytes = _parseBytes(result, start);\n    if (bytes == null)\n      return null;\n    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.toUtf8String)(bytes);\n  } catch (error) {\n  }\n  return null;\n}\nvar ccipLookup = async (provider, transaction, result) => {\n  const txSender = transaction.to;\n  try {\n    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(result, 4);\n    const sender = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(data, 0, 32);\n    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(sender).eq(txSender)) {\n      throw new Error(\"CCIP Read sender did not match\");\n    }\n    const urls = [];\n    const urlsOffset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(data, 32, 64)).toNumber();\n    const urlsLength = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(\n      (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(data, urlsOffset, urlsOffset + 32)\n    ).toNumber();\n    const urlsData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(data, urlsOffset + 32);\n    for (let u = 0; u < urlsLength; u += 1) {\n      const url = _parseString(urlsData, u * 32);\n      if (url == null) {\n        throw new Error(\"CCIP Read contained corrupt URL string\");\n      }\n      urls.push(url);\n    }\n    const calldata = _parseBytes(data, 64);\n    if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(data, 100, 128)).isZero()) {\n      throw new Error(\"CCIP Read callback selected included junk\");\n    }\n    const callbackSelector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexDataSlice)(data, 96, 100);\n    const extraData = _parseBytes(data, 128);\n    const ccipResult = await provider.ccipReadFetch(\n      transaction,\n      calldata,\n      urls\n    );\n    if (ccipResult == null) {\n      throw new Error(\"CCIP Read disabled or provided no URLs\");\n    }\n    const tx = {\n      to: txSender,\n      data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexConcat)([\n        callbackSelector,\n        encodeBytes([ccipResult, extraData])\n      ])\n    };\n    return await provider._call(tx, \"latest\", 1);\n  } catch (error) {\n    console.error(error);\n  }\n};\nvar ccip_default = ccipLookup;\n\n\n\n//# sourceURL=webpack://dapp/./node_modules/@ensdomains/ensjs/dist/esm/utils/ccip.mjs?");

/***/ }),

/***/ "./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hexDecodeName: () => (/* binding */ hexDecodeName),\n/* harmony export */   hexEncodeName: () => (/* binding */ hexEncodeName)\n/* harmony export */ });\n/* harmony import */ var dns_packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dns-packet */ \"./node_modules/dns-packet/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n// src/utils/hexEncodedName.ts\n\nvar hexEncodeName = (name) => `0x${dns_packet__WEBPACK_IMPORTED_MODULE_0__.name.encode(name).toString(\"hex\")}`;\nvar hexDecodeName = (hex) => dns_packet__WEBPACK_IMPORTED_MODULE_0__.name.decode(Buffer.from(hex.slice(2), \"hex\")).toString();\n\n\n\n//# sourceURL=webpack://dapp/./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs?");

/***/ })

}]);