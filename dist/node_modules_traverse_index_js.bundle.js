"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkdapp"] = self["webpackChunkdapp"] || []).push([["node_modules_traverse_index_js"],{

/***/ "./node_modules/traverse/index.js":
/*!****************************************!*\
  !*** ./node_modules/traverse/index.js ***!
  \****************************************/
/***/ ((module) => {

eval("\n\n// TODO: use call-bind, is-date, is-regex, is-string, is-boolean-object, is-number-object\nfunction toS(obj) { return Object.prototype.toString.call(obj); }\nfunction isDate(obj) { return toS(obj) === '[object Date]'; }\nfunction isRegExp(obj) { return toS(obj) === '[object RegExp]'; }\nfunction isError(obj) { return toS(obj) === '[object Error]'; }\nfunction isBoolean(obj) { return toS(obj) === '[object Boolean]'; }\nfunction isNumber(obj) { return toS(obj) === '[object Number]'; }\nfunction isString(obj) { return toS(obj) === '[object String]'; }\n\n// TODO: use isarray\nvar isArray = Array.isArray || function isArray(xs) {\n\treturn Object.prototype.toString.call(xs) === '[object Array]';\n};\n\n// TODO: use for-each?\nfunction forEach(xs, fn) {\n\tif (xs.forEach) { return xs.forEach(fn); }\n\tfor (var i = 0; i < xs.length; i++) {\n\t\tfn(xs[i], i, xs);\n\t}\n\treturn void undefined;\n}\n\n// TODO: use object-keys\nvar objectKeys = Object.keys || function keys(obj) {\n\tvar res = [];\n\tfor (var key in obj) { res.push(key); } // eslint-disable-line no-restricted-syntax\n\treturn res;\n};\n\n// TODO: use object.hasown\nvar hasOwnProperty = Object.prototype.hasOwnProperty || function (obj, key) {\n\treturn key in obj;\n};\n\nfunction copy(src) {\n\tif (typeof src === 'object' && src !== null) {\n\t\tvar dst;\n\n\t\tif (isArray(src)) {\n\t\t\tdst = [];\n\t\t} else if (isDate(src)) {\n\t\t\tdst = new Date(src.getTime ? src.getTime() : src);\n\t\t} else if (isRegExp(src)) {\n\t\t\tdst = new RegExp(src);\n\t\t} else if (isError(src)) {\n\t\t\tdst = { message: src.message };\n\t\t} else if (isBoolean(src) || isNumber(src) || isString(src)) {\n\t\t\tdst = Object(src);\n\t\t} else if (Object.create && Object.getPrototypeOf) {\n\t\t\tdst = Object.create(Object.getPrototypeOf(src));\n\t\t} else if (src.constructor === Object) {\n\t\t\tdst = {};\n\t\t} else {\n\t\t\tvar proto = (src.constructor && src.constructor.prototype)\n                || src.__proto__\n                || {};\n\t\t\tvar T = function T() {}; // eslint-disable-line func-style, func-name-matching\n\t\t\tT.prototype = proto;\n\t\t\tdst = new T();\n\t\t}\n\n\t\tforEach(objectKeys(src), function (key) {\n\t\t\tdst[key] = src[key];\n\t\t});\n\t\treturn dst;\n\t}\n\treturn src;\n}\n\nfunction walk(root, cb, immutable) {\n\tvar path = [];\n\tvar parents = [];\n\tvar alive = true;\n\n\treturn (function walker(node_) {\n\t\tvar node = immutable ? copy(node_) : node_;\n\t\tvar modifiers = {};\n\n\t\tvar keepGoing = true;\n\n\t\tvar state = {\n\t\t\tnode: node,\n\t\t\tnode_: node_,\n\t\t\tpath: [].concat(path),\n\t\t\tparent: parents[parents.length - 1],\n\t\t\tparents: parents,\n\t\t\tkey: path[path.length - 1],\n\t\t\tisRoot: path.length === 0,\n\t\t\tlevel: path.length,\n\t\t\tcircular: null,\n\t\t\tupdate: function (x, stopHere) {\n\t\t\t\tif (!state.isRoot) {\n\t\t\t\t\tstate.parent.node[state.key] = x;\n\t\t\t\t}\n\t\t\t\tstate.node = x;\n\t\t\t\tif (stopHere) { keepGoing = false; }\n\t\t\t},\n\t\t\tdelete: function (stopHere) {\n\t\t\t\tdelete state.parent.node[state.key];\n\t\t\t\tif (stopHere) { keepGoing = false; }\n\t\t\t},\n\t\t\tremove: function (stopHere) {\n\t\t\t\tif (isArray(state.parent.node)) {\n\t\t\t\t\tstate.parent.node.splice(state.key, 1);\n\t\t\t\t} else {\n\t\t\t\t\tdelete state.parent.node[state.key];\n\t\t\t\t}\n\t\t\t\tif (stopHere) { keepGoing = false; }\n\t\t\t},\n\t\t\tkeys: null,\n\t\t\tbefore: function (f) { modifiers.before = f; },\n\t\t\tafter: function (f) { modifiers.after = f; },\n\t\t\tpre: function (f) { modifiers.pre = f; },\n\t\t\tpost: function (f) { modifiers.post = f; },\n\t\t\tstop: function () { alive = false; },\n\t\t\tblock: function () { keepGoing = false; },\n\t\t};\n\n\t\tif (!alive) { return state; }\n\n\t\tfunction updateState() {\n\t\t\tif (typeof state.node === 'object' && state.node !== null) {\n\t\t\t\tif (!state.keys || state.node_ !== state.node) {\n\t\t\t\t\tstate.keys = objectKeys(state.node);\n\t\t\t\t}\n\n\t\t\t\tstate.isLeaf = state.keys.length === 0;\n\n\t\t\t\tfor (var i = 0; i < parents.length; i++) {\n\t\t\t\t\tif (parents[i].node_ === node_) {\n\t\t\t\t\t\tstate.circular = parents[i];\n\t\t\t\t\t\tbreak; // eslint-disable-line no-restricted-syntax\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstate.isLeaf = true;\n\t\t\t\tstate.keys = null;\n\t\t\t}\n\n\t\t\tstate.notLeaf = !state.isLeaf;\n\t\t\tstate.notRoot = !state.isRoot;\n\t\t}\n\n\t\tupdateState();\n\n\t\t// use return values to update if defined\n\t\tvar ret = cb.call(state, state.node);\n\t\tif (ret !== undefined && state.update) { state.update(ret); }\n\n\t\tif (modifiers.before) { modifiers.before.call(state, state.node); }\n\n\t\tif (!keepGoing) { return state; }\n\n\t\tif (\n\t\t\ttypeof state.node === 'object'\n\t\t\t&& state.node !== null\n\t\t\t&& !state.circular\n\t\t) {\n\t\t\tparents.push(state);\n\n\t\t\tupdateState();\n\n\t\t\tforEach(state.keys, function (key, i) {\n\t\t\t\tpath.push(key);\n\n\t\t\t\tif (modifiers.pre) { modifiers.pre.call(state, state.node[key], key); }\n\n\t\t\t\tvar child = walker(state.node[key]);\n\t\t\t\tif (immutable && hasOwnProperty.call(state.node, key)) {\n\t\t\t\t\tstate.node[key] = child.node;\n\t\t\t\t}\n\n\t\t\t\tchild.isLast = i === state.keys.length - 1;\n\t\t\t\tchild.isFirst = i === 0;\n\n\t\t\t\tif (modifiers.post) { modifiers.post.call(state, child); }\n\n\t\t\t\tpath.pop();\n\t\t\t});\n\t\t\tparents.pop();\n\t\t}\n\n\t\tif (modifiers.after) { modifiers.after.call(state, state.node); }\n\n\t\treturn state;\n\t}(root)).node;\n}\n\nfunction Traverse(obj) {\n\tthis.value = obj;\n}\n\nTraverse.prototype.get = function (ps) {\n\tvar node = this.value;\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tvar key = ps[i];\n\t\tif (!node || !hasOwnProperty.call(node, key)) {\n\t\t\treturn void undefined;\n\t\t}\n\t\tnode = node[key];\n\t}\n\treturn node;\n};\n\nTraverse.prototype.has = function (ps) {\n\tvar node = this.value;\n\tfor (var i = 0; i < ps.length; i++) {\n\t\tvar key = ps[i];\n\t\tif (!node || !hasOwnProperty.call(node, key)) {\n\t\t\treturn false;\n\t\t}\n\t\tnode = node[key];\n\t}\n\treturn true;\n};\n\nTraverse.prototype.set = function (ps, value) {\n\tvar node = this.value;\n\tfor (var i = 0; i < ps.length - 1; i++) {\n\t\tvar key = ps[i];\n\t\tif (!hasOwnProperty.call(node, key)) { node[key] = {}; }\n\t\tnode = node[key];\n\t}\n\tnode[ps[i]] = value;\n\treturn value;\n};\n\nTraverse.prototype.map = function (cb) {\n\treturn walk(this.value, cb, true);\n};\n\nTraverse.prototype.forEach = function (cb) {\n\tthis.value = walk(this.value, cb, false);\n\treturn this.value;\n};\n\nTraverse.prototype.reduce = function (cb, init) {\n\tvar skip = arguments.length === 1;\n\tvar acc = skip ? this.value : init;\n\tthis.forEach(function (x) {\n\t\tif (!this.isRoot || !skip) {\n\t\t\tacc = cb.call(this, acc, x);\n\t\t}\n\t});\n\treturn acc;\n};\n\nTraverse.prototype.paths = function () {\n\tvar acc = [];\n\tthis.forEach(function () {\n\t\tacc.push(this.path);\n\t});\n\treturn acc;\n};\n\nTraverse.prototype.nodes = function () {\n\tvar acc = [];\n\tthis.forEach(function () {\n\t\tacc.push(this.node);\n\t});\n\treturn acc;\n};\n\nTraverse.prototype.clone = function () {\n\tvar parents = [];\n\tvar nodes = [];\n\n\treturn (function clone(src) {\n\t\tfor (var i = 0; i < parents.length; i++) {\n\t\t\tif (parents[i] === src) {\n\t\t\t\treturn nodes[i];\n\t\t\t}\n\t\t}\n\n\t\tif (typeof src === 'object' && src !== null) {\n\t\t\tvar dst = copy(src);\n\n\t\t\tparents.push(src);\n\t\t\tnodes.push(dst);\n\n\t\t\tforEach(objectKeys(src), function (key) {\n\t\t\t\tdst[key] = clone(src[key]);\n\t\t\t});\n\n\t\t\tparents.pop();\n\t\t\tnodes.pop();\n\t\t\treturn dst;\n\t\t}\n\n\t\treturn src;\n\n\t}(this.value));\n};\n\nfunction traverse(obj) {\n\treturn new Traverse(obj);\n}\n\n// TODO: replace with object.assign?\nforEach(objectKeys(Traverse.prototype), function (key) {\n\ttraverse[key] = function (obj) {\n\t\tvar args = [].slice.call(arguments, 1);\n\t\tvar t = new Traverse(obj);\n\t\treturn t[key].apply(t, args);\n\t};\n});\n\nmodule.exports = traverse;\n\n\n//# sourceURL=webpack://dapp/./node_modules/traverse/index.js?");

/***/ })

}]);