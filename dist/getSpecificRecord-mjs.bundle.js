/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkdapp"] = self["webpackChunkdapp"] || []).push([["getSpecificRecord-mjs"],{

/***/ "?ed5d":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://dapp/buffer_(ignored)?");

/***/ }),

/***/ "./node_modules/@ensdomains/ensjs/dist/esm/functions/getSpecificRecord.mjs":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ensdomains/ensjs/dist/esm/functions/getSpecificRecord.mjs ***!
  \*********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _getABI: () => (/* binding */ _getABI),\n/* harmony export */   _getAddr: () => (/* binding */ _getAddr),\n/* harmony export */   _getContentHash: () => (/* binding */ _getContentHash),\n/* harmony export */   _getText: () => (/* binding */ _getText),\n/* harmony export */   getABI: () => (/* binding */ getABI),\n/* harmony export */   getAddr: () => (/* binding */ getAddr),\n/* harmony export */   getContentHash: () => (/* binding */ getContentHash),\n/* harmony export */   getText: () => (/* binding */ getText)\n/* harmony export */ });\n/* harmony import */ var _ensdomains_address_encoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ensdomains/address-encoder */ \"./node_modules/@ensdomains/address-encoder/lib/index.module.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ \"./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/strings */ \"./node_modules/@ethersproject/strings/lib.esm/utf8.js\");\n/* harmony import */ var _utils_contentHash_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/contentHash.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/contentHash.mjs\");\n/* harmony import */ var _utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/normalise.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/normalise.mjs\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n// src/functions/getSpecificRecord.ts\n\n\n\n\n\nvar _getContentHash = {\n  raw: async ({ contracts }, name) => {\n    const publicResolver = await contracts?.getPublicResolver();\n    return {\n      to: \"0x0000000000000000000000000000000000000000\",\n      data: publicResolver.interface.encodeFunctionData(\"contenthash\", [\n        (0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_2__.namehash)(name)\n      ])\n    };\n  },\n  decode: async ({ contracts }, data) => {\n    let response;\n    const publicResolver = await contracts?.getPublicResolver();\n    try {\n      ;\n      [response] = publicResolver.interface.decodeFunctionResult(\n        \"contenthash\",\n        data\n      );\n    } catch {\n      return;\n    }\n    if (!response) {\n      return;\n    }\n    const decodedContent = (0,_utils_contentHash_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeContenthash)(response);\n    if (!decodedContent || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytesLike)(decodedContent.decoded) && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexStripZeros)(decodedContent.decoded) === \"0x\" || Object.keys(decodedContent).length === 0) {\n      return;\n    }\n    return decodedContent;\n  }\n};\nvar getContentHash = {\n  raw: async ({ contracts, universalWrapper }, name) => {\n    const prData = await _getContentHash.raw({ contracts }, name);\n    return universalWrapper.raw(name, prData.data);\n  },\n  decode: async ({ contracts, universalWrapper }, data) => {\n    const urData = await universalWrapper.decode(data);\n    if (!urData)\n      return;\n    return _getContentHash.decode({ contracts }, urData.data);\n  }\n};\nvar _getText = {\n  raw: async ({ contracts }, name, key) => {\n    const publicResolver = await contracts?.getPublicResolver();\n    return {\n      to: \"0x0000000000000000000000000000000000000000\",\n      data: publicResolver.interface.encodeFunctionData(\"text\", [\n        (0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_2__.namehash)(name),\n        key\n      ])\n    };\n  },\n  decode: async ({ contracts }, data) => {\n    const publicResolver = await contracts?.getPublicResolver();\n    const [response] = publicResolver.interface.decodeFunctionResult(\n      \"text\",\n      data\n    );\n    if (!response) {\n      return;\n    }\n    return response;\n  }\n};\nvar getText = {\n  raw: async ({ contracts, universalWrapper }, name, key) => {\n    const prData = await _getText.raw({ contracts }, name, key);\n    return universalWrapper.raw(name, prData.data);\n  },\n  decode: async ({ contracts, universalWrapper }, data) => {\n    const urData = await universalWrapper.decode(data);\n    if (!urData)\n      return;\n    return _getText.decode({ contracts }, urData.data);\n  }\n};\nvar _getAddr = {\n  raw: async ({ contracts }, name, coinType, bypassFormat) => {\n    if (!coinType) {\n      coinType = 60;\n    }\n    const publicResolver = await contracts?.getPublicResolver();\n    if (coinType === 60 || coinType === \"60\") {\n      return {\n        to: \"0x0000000000000000000000000000000000000000\",\n        data: publicResolver.interface.encodeFunctionData(\"addr(bytes32)\", [\n          (0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_2__.namehash)(name)\n        ])\n      };\n    }\n    if (bypassFormat) {\n      return {\n        to: \"0x0000000000000000000000000000000000000000\",\n        data: publicResolver.interface.encodeFunctionData(\n          \"addr(bytes32,uint256)\",\n          [(0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_2__.namehash)(name), coinType]\n        )\n      };\n    }\n    const formatter = typeof coinType === \"string\" && Number.isNaN(parseInt(coinType)) ? _ensdomains_address_encoder__WEBPACK_IMPORTED_MODULE_0__.formatsByName[coinType] : _ensdomains_address_encoder__WEBPACK_IMPORTED_MODULE_0__.formatsByCoinType[typeof coinType === \"number\" ? coinType : parseInt(coinType)];\n    if (!formatter) {\n      throw new Error(`No formatter found for coin: ${coinType}`);\n    }\n    return {\n      to: \"0x0000000000000000000000000000000000000000\",\n      data: publicResolver.interface.encodeFunctionData(\n        \"addr(bytes32,uint256)\",\n        [(0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_2__.namehash)(name), formatter.coinType]\n      )\n    };\n  },\n  decode: async ({ contracts }, data, _name, coinType) => {\n    let returnCoinType = true;\n    if (!coinType) {\n      coinType = 60;\n      returnCoinType = false;\n    }\n    const publicResolver = await contracts?.getPublicResolver();\n    const formatter = typeof coinType === \"string\" && Number.isNaN(parseInt(coinType)) ? _ensdomains_address_encoder__WEBPACK_IMPORTED_MODULE_0__.formatsByName[coinType] : _ensdomains_address_encoder__WEBPACK_IMPORTED_MODULE_0__.formatsByCoinType[typeof coinType === \"number\" ? coinType : parseInt(coinType)];\n    let response;\n    if (coinType === 60 || coinType === \"60\") {\n      ;\n      [response] = publicResolver.interface.decodeFunctionResult(\n        \"addr(bytes32)\",\n        data\n      );\n    } else {\n      ;\n      [response] = publicResolver.interface.decodeFunctionResult(\n        \"addr(bytes32,uint256)\",\n        data\n      );\n    }\n    if (!response)\n      return;\n    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexStripZeros)(response) === \"0x\") {\n      return;\n    }\n    const decodedAddr = formatter.encoder(Buffer.from(response.slice(2), \"hex\"));\n    if (!decodedAddr) {\n      return;\n    }\n    if (!returnCoinType) {\n      return decodedAddr;\n    }\n    return { coin: formatter.name, addr: decodedAddr };\n  }\n};\nvar getAddr = {\n  raw: async ({ contracts, universalWrapper }, name, coinType) => {\n    const prData = await _getAddr.raw({ contracts }, name, coinType);\n    return universalWrapper.raw(name, prData.data);\n  },\n  decode: async ({ contracts, universalWrapper }, data, _name, coinType) => {\n    const urData = await universalWrapper.decode(data);\n    if (!urData)\n      return;\n    return _getAddr.decode({ contracts }, urData.data, _name, coinType);\n  }\n};\nvar supportedContentTypes = \"0xf\";\nvar _getABI = {\n  raw: async ({ contracts }, name) => {\n    const publicResolver = await contracts?.getPublicResolver();\n    return {\n      to: \"0x0000000000000000000000000000000000000000\",\n      data: publicResolver.interface.encodeFunctionData(\"ABI\", [\n        (0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_2__.namehash)(name),\n        supportedContentTypes\n      ])\n    };\n  },\n  decode: async ({ contracts }, data) => {\n    const publicResolver = await contracts?.getPublicResolver();\n    const [bnContentType, encodedABIData] = publicResolver.interface.decodeFunctionResult(\"ABI\", data);\n    if (!bnContentType || !data) {\n      return;\n    }\n    const contentType = bnContentType.toNumber();\n    if (!contentType) {\n      return;\n    }\n    let abiData;\n    let decoded = false;\n    switch (contentType) {\n      case 1:\n        abiData = JSON.parse((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_4__.toUtf8String)(encodedABIData));\n        decoded = true;\n        break;\n      case 2: {\n        const { inflate } = await __webpack_require__.e(/*! import() */ \"vendors-node_modules_pako_dist_pako_inflate_min_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! pako/dist/pako_inflate.min.js */ \"./node_modules/pako/dist/pako_inflate.min.js\", 19));\n        abiData = JSON.parse(\n          inflate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(encodedABIData), { to: \"string\" })\n        );\n        decoded = true;\n        break;\n      }\n      case 4: {\n        const { decodeFirst } = await Promise.all(/*! import() */[__webpack_require__.e(\"vendors-node_modules_cbor_lib_cbor_js\"), __webpack_require__.e(\"_ed1b-_d17e\")]).then(__webpack_require__.t.bind(__webpack_require__, /*! cbor */ \"./node_modules/cbor/lib/cbor.js\", 19));\n        abiData = await decodeFirst((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(encodedABIData));\n        decoded = true;\n        break;\n      }\n      case 8:\n        abiData = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_4__.toUtf8String)(encodedABIData);\n        decoded = false;\n        break;\n      default:\n        try {\n          abiData = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_4__.toUtf8String)(encodedABIData);\n        } catch {\n          abiData = encodedABIData;\n        }\n        decoded = false;\n    }\n    return {\n      contentType,\n      decoded,\n      abi: abiData\n    };\n  }\n};\nvar getABI = {\n  raw: async ({ contracts, universalWrapper }, name) => {\n    const prData = await _getABI.raw({ contracts }, name);\n    return universalWrapper.raw(name, prData.data);\n  },\n  decode: async ({ contracts, universalWrapper }, data) => {\n    const urData = await universalWrapper.decode(data);\n    if (!urData)\n      return;\n    return _getABI.decode({ contracts }, urData.data);\n  }\n};\n\n\n\n//# sourceURL=webpack://dapp/./node_modules/@ensdomains/ensjs/dist/esm/functions/getSpecificRecord.mjs?");

/***/ })

}]);