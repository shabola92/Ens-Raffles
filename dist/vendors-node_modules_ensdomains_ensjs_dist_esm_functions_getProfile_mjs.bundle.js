"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkdapp"] = self["webpackChunkdapp"] || []).push([["vendors-node_modules_ensdomains_ensjs_dist_esm_functions_getProfile_mjs"],{

/***/ "./node_modules/@ensdomains/ensjs/dist/esm/functions/getProfile.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@ensdomains/ensjs/dist/esm/functions/getProfile.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ getProfile_default)\n/* harmony export */ });\n/* harmony import */ var _ensdomains_address_encoder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ensdomains/address-encoder */ \"./node_modules/@ensdomains/address-encoder/lib/index.module.js\");\n/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/abi */ \"./node_modules/@ethersproject/abi/lib.esm/abi-coder.js\");\n/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/address */ \"./node_modules/@ethersproject/address/lib.esm/index.js\");\n/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ \"./node_modules/@ethersproject/bytes/lib.esm/index.js\");\n/* harmony import */ var _utils_contentHash_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/contentHash.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/contentHash.mjs\");\n/* harmony import */ var _utils_hexEncodedName_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/hexEncodedName.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs\");\n/* harmony import */ var _utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/normalise.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/normalise.mjs\");\n/* harmony import */ var _utils_errors_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/errors.mjs */ \"./node_modules/@ensdomains/ensjs/dist/esm/utils/errors.mjs\");\n// src/functions/getProfile.ts\n\n\n\n\n\n\n\n\nvar makeMulticallData = async ({\n  _getAddr,\n  _getContentHash,\n  _getText\n}, name, options) => {\n  let calls = [];\n  if (options.texts)\n    calls = [\n      ...calls,\n      ...await Promise.all(\n        options.texts.map(async (x) => ({\n          key: x,\n          data: await _getText.raw(name, x),\n          type: \"text\"\n        }))\n      )\n    ];\n  if (options.coinTypes)\n    calls = [\n      ...calls,\n      ...await Promise.all(\n        options.coinTypes.map(async (x) => ({\n          key: x,\n          data: await _getAddr.raw(name, x, true),\n          type: \"addr\"\n        }))\n      )\n    ];\n  if (typeof options.contentHash === \"boolean\" && options.contentHash) {\n    calls.push({\n      key: \"contentHash\",\n      data: await _getContentHash.raw(name),\n      type: \"contentHash\"\n    });\n  }\n  if (!calls.find((x) => x.key === \"60\")) {\n    calls.push({\n      key: \"60\",\n      data: await _getAddr.raw(name, \"60\", true),\n      type: \"addr\"\n    });\n  }\n  return { data: calls.map((x) => x.data.data), calls };\n};\nvar fetchWithoutResolverMulticall = async ({ multicallWrapper }, calls, resolverAddress) => {\n  const callsWithResolver = calls.map((call) => ({\n    to: resolverAddress,\n    data: call.data.data\n  }));\n  const results = await multicallWrapper(callsWithResolver);\n  if (!results || !results.length)\n    return [];\n  return results.map((x) => x[1]);\n};\nvar formatRecords = async ({\n  _getText,\n  _getAddr,\n  _getContentHash\n}, data, calls, options) => {\n  const returnedRecords = (await Promise.all(\n    data.map(async (item, i) => {\n      let decodedFromAbi;\n      let itemRet = {\n        key: calls[i].key,\n        type: calls[i].type\n      };\n      if (itemRet.type === \"contentHash\") {\n        ;\n        [decodedFromAbi] = _ethersproject_abi__WEBPACK_IMPORTED_MODULE_5__.defaultAbiCoder.decode([\"bytes\"], item);\n        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexStripZeros)(decodedFromAbi) === \"0x\") {\n          return;\n        }\n      }\n      switch (calls[i].type) {\n        case \"text\":\n          itemRet = {\n            ...itemRet,\n            value: await _getText.decode(item)\n          };\n          if (itemRet.value === \"\" || itemRet.value === void 0)\n            return;\n          break;\n        case \"addr\":\n          try {\n            const addr = await _getAddr.decode(item, \"\", calls[i].key);\n            if (addr) {\n              itemRet = {\n                ...itemRet,\n                ...addr\n              };\n              break;\n            } else {\n              return;\n            }\n          } catch {\n            return;\n          }\n        case \"contentHash\":\n          try {\n            itemRet = {\n              ...itemRet,\n              value: await _getContentHash.decode(item)\n            };\n            break;\n          } catch {\n            return;\n          }\n      }\n      return itemRet;\n    })\n  )).filter((x) => {\n    return typeof x === \"object\";\n  }).filter((x) => x);\n  const returnedResponse = {};\n  if (typeof options.contentHash === \"string\" || typeof options.contentHash === \"object\") {\n    if (typeof options.contentHash === \"string\" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexStripZeros)(options.contentHash) === \"0x\") {\n      returnedResponse.contentHash = null;\n    } else if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytesLike)(options.contentHash.decoded) && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexStripZeros)(options.contentHash.decoded) === \"0x\") {\n      returnedResponse.contentHash = null;\n    } else {\n      returnedResponse.contentHash = options.contentHash;\n    }\n  } else if (options.contentHash) {\n    const foundRecord = returnedRecords.find(\n      (item) => item.type === \"contentHash\"\n    );\n    returnedResponse.contentHash = foundRecord ? foundRecord.value : null;\n  }\n  if (options.texts) {\n    returnedResponse.texts = returnedRecords.filter(\n      (x) => x.type === \"text\"\n    );\n  }\n  if (options.coinTypes) {\n    returnedResponse.coinTypes = returnedRecords.filter(\n      (x) => x.type === \"addr\"\n    );\n  }\n  return returnedResponse;\n};\nvar getDataForName = async ({\n  contracts,\n  _getAddr,\n  _getContentHash,\n  _getText,\n  multicallWrapper\n}, name, options, specificResolver) => {\n  const universalResolver = await contracts?.getUniversalResolver();\n  const { data, calls } = await makeMulticallData(\n    { _getAddr, _getContentHash, _getText },\n    name,\n    options\n  );\n  let recordData;\n  let resolverAddress = specificResolver;\n  if (specificResolver) {\n    try {\n      const publicResolver = await contracts?.getPublicResolver(\n        void 0,\n        specificResolver\n      );\n      recordData = await publicResolver?.callStatic.multicall(data);\n    } catch (e) {\n      console.error(\"getProfile error:\", e);\n      recordData = await fetchWithoutResolverMulticall(\n        { multicallWrapper },\n        calls,\n        resolverAddress\n      );\n    }\n  } else {\n    try {\n      const resolvedData = await universalResolver[\"resolve(bytes,bytes[])\"](\n        (0,_utils_hexEncodedName_mjs__WEBPACK_IMPORTED_MODULE_2__.hexEncodeName)(name),\n        data,\n        {\n          ccipReadEnabled: true\n        }\n      );\n      recordData = [...resolvedData[\"0\"]];\n      resolverAddress = resolvedData[\"1\"];\n      for (let i = 0; i < recordData.length; i += 1) {\n        if (recordData[i].startsWith(\"0x0d1947a9\") || recordData[i] === \"0x\") {\n          calls[i] = null;\n          recordData[i] = null;\n        }\n      }\n    } catch {\n      const registryContract = await contracts?.getRegistry();\n      resolverAddress = await registryContract?.resolver((0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_3__.namehash)(name));\n      return {\n        address: void 0,\n        records: {},\n        resolverAddress,\n        isInvalidResolverAddress: true\n      };\n    }\n  }\n  if (!resolverAddress || !recordData || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexStripZeros)(resolverAddress) === \"0x\") {\n    return {\n      address: void 0,\n      records: {},\n      resolverAddress: void 0\n    };\n  }\n  const filteredCalls = calls.filter((x) => x);\n  const filteredRecordData = recordData.filter((x) => x);\n  const matchAddress = filteredRecordData[filteredCalls.findIndex((x) => x.key === \"60\")];\n  return {\n    address: matchAddress && await _getAddr.decode(matchAddress).catch(() => false),\n    records: await formatRecords(\n      { _getAddr, _getContentHash, _getText },\n      filteredRecordData,\n      filteredCalls,\n      options\n    ),\n    resolverAddress\n  };\n};\nvar graphFetch = async ({ gqlInstance }, name, wantedRecords, resolverAddress, skipGraph = true) => {\n  if (skipGraph)\n    return { status: void 0, result: void 0 };\n  const query = gqlInstance.gql`\n    query getRecords($id: String!) {\n      domain(id: $id) {\n        name\n        isMigrated\n        createdAt\n        resolver {\n          texts\n          coinTypes\n          contentHash\n          addr {\n            id\n          }\n        }\n      }\n    }\n  `;\n  const customResolverQuery = gqlInstance.gql`\n    query getRecordsWithCustomResolver($id: String!, $resolverId: String!) {\n      domain(id: $id) {\n        name\n        isMigrated\n        createdAt\n      }\n      resolver(id: $resolverId) {\n        texts\n        coinTypes\n        contentHash\n        addr {\n          id\n        }\n      }\n    }\n  `;\n  const { client } = gqlInstance;\n  const id = (0,_utils_normalise_mjs__WEBPACK_IMPORTED_MODULE_3__.namehash)(name);\n  let domain;\n  let resolverResponse;\n  let graphErrors;\n  if (!resolverAddress) {\n    const response = await client.request(query, { id }).catch((e) => {\n      graphErrors = (0,_utils_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.getClientErrors)(e);\n      return void 0;\n    }).finally(_utils_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.debugSubgraphLatency);\n    domain = response?.domain;\n    resolverResponse = domain?.resolver;\n  } else {\n    const resolverId = `${resolverAddress.toLowerCase()}-${id}`;\n    const response = await client.request(customResolverQuery, {\n      id,\n      resolverId\n    }).catch((e) => {\n      graphErrors = (0,_utils_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.getClientErrors)(e);\n      return void 0;\n    }).finally(_utils_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.debugSubgraphLatency);\n    resolverResponse = response?.resolver;\n    domain = response?.domain;\n  }\n  if (!domain)\n    return { errors: graphErrors };\n  const { isMigrated, createdAt, name: decryptedName } = domain;\n  const returnedRecords = {};\n  if (!resolverResponse || !wantedRecords)\n    return {\n      errors: graphErrors,\n      result: { isMigrated, createdAt, decryptedName }\n    };\n  Object.keys(wantedRecords).forEach((key) => {\n    const data = wantedRecords[key];\n    if (typeof data === \"boolean\" && data) {\n      if (key === \"contentHash\") {\n        returnedRecords[key] = (0,_utils_contentHash_mjs__WEBPACK_IMPORTED_MODULE_1__.decodeContenthash)(resolverResponse.contentHash);\n      } else {\n        returnedRecords[key] = resolverResponse[key];\n      }\n    }\n  });\n  return {\n    errors: graphErrors,\n    result: {\n      ...returnedRecords,\n      decryptedName,\n      isMigrated,\n      createdAt\n    }\n  };\n};\nvar getProfileFromName = async ({\n  contracts,\n  gqlInstance,\n  _getAddr,\n  _getContentHash,\n  _getText,\n  resolverMulticallWrapper,\n  multicallWrapper\n}, name, options) => {\n  const { resolverAddress, fallback, skipGraph, ..._options } = options || {};\n  const optsLength = Object.keys(_options).length;\n  let usingOptions;\n  if (!optsLength || _options?.texts === true || _options?.coinTypes === true) {\n    if (optsLength)\n      usingOptions = _options;\n    else\n      usingOptions = { contentHash: true, texts: true, coinTypes: true };\n  }\n  const { errors, result: graphResult } = await graphFetch(\n    { gqlInstance },\n    name,\n    usingOptions,\n    resolverAddress,\n    !!skipGraph\n  );\n  let isMigrated = null;\n  let createdAt = null;\n  let decryptedName = null;\n  let result = null;\n  if (!graphResult) {\n    if (!fallback)\n      return { errors };\n    result = await getDataForName(\n      {\n        contracts,\n        _getAddr,\n        _getContentHash,\n        _getText,\n        resolverMulticallWrapper,\n        multicallWrapper\n      },\n      name,\n      fallback,\n      void 0\n    );\n  } else {\n    const {\n      isMigrated: _isMigrated,\n      createdAt: _createdAt,\n      decryptedName: _decryptedName,\n      ...wantedRecords\n    } = graphResult;\n    isMigrated = _isMigrated;\n    createdAt = _createdAt;\n    decryptedName = _decryptedName;\n    let recordsWithFallback = usingOptions ? wantedRecords : _options;\n    if ((Object.keys(recordsWithFallback).length === 0 || !recordsWithFallback.coinTypes && !recordsWithFallback.texts && Object.keys(recordsWithFallback.contentHash || {}).length === 0) && fallback) {\n      recordsWithFallback = fallback;\n    }\n    result = await getDataForName(\n      {\n        contracts,\n        _getAddr,\n        _getContentHash,\n        _getText,\n        resolverMulticallWrapper,\n        multicallWrapper\n      },\n      name,\n      recordsWithFallback,\n      options?.resolverAddress\n    );\n  }\n  if (!result?.resolverAddress)\n    return {\n      errors,\n      result: {\n        isMigrated,\n        createdAt,\n        message: !result ? \"Records fetch didn't complete\" : \"Name doesn't have a resolver\"\n      }\n    };\n  return {\n    errors,\n    result: {\n      ...result,\n      isMigrated,\n      createdAt,\n      decryptedName,\n      message: void 0\n    }\n  };\n};\nvar getProfileFromAddress = async ({\n  contracts,\n  gqlInstance,\n  getName,\n  _getAddr,\n  _getContentHash,\n  _getText,\n  resolverMulticallWrapper,\n  multicallWrapper\n}, address, options) => {\n  let name;\n  try {\n    name = await getName(address);\n  } catch (e) {\n    return {};\n  }\n  if (!name || !name.name || name.name === \"\")\n    return {};\n  if (!name.match)\n    return {\n      result: { ...name, isMigrated: null, createdAt: null }\n    };\n  const { errors, result } = await getProfileFromName(\n    {\n      contracts,\n      gqlInstance,\n      _getAddr,\n      _getContentHash,\n      _getText,\n      resolverMulticallWrapper,\n      multicallWrapper\n    },\n    name.name,\n    options\n  );\n  if (!result || result.message)\n    return { errors };\n  delete result.address;\n  return {\n    errors,\n    result: {\n      ...result,\n      ...name,\n      message: void 0\n    }\n  };\n};\nvar mapCoinTypes = (coin) => {\n  if (!Number.isNaN(parseInt(coin))) {\n    return coin;\n  }\n  return `${_ensdomains_address_encoder__WEBPACK_IMPORTED_MODULE_0__.formatsByName[coin.toUpperCase()].coinType}`;\n};\nasync function getProfile_default({\n  contracts,\n  gqlInstance,\n  getName,\n  _getAddr,\n  _getContentHash,\n  _getText,\n  resolverMulticallWrapper,\n  multicallWrapper\n}, nameOrAddress, options) {\n  if (options) {\n    if (options.coinTypes && typeof options.coinTypes !== \"boolean\") {\n      options.coinTypes = options.coinTypes.map(mapCoinTypes);\n    }\n    if (options.fallback && options.fallback.coinTypes) {\n      options.fallback.coinTypes = options.fallback.coinTypes.map(mapCoinTypes);\n    }\n  }\n  const inputIsAddress = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_7__.isAddress)(nameOrAddress);\n  if (inputIsAddress) {\n    const { errors: errors2, result: result2 } = await getProfileFromAddress(\n      {\n        contracts,\n        gqlInstance,\n        getName,\n        _getAddr,\n        _getContentHash,\n        _getText,\n        resolverMulticallWrapper,\n        multicallWrapper\n      },\n      nameOrAddress,\n      options\n    );\n    if (errors2)\n      throw new _utils_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.ENSJSError({ data: result2, errors: errors2 });\n    return result2;\n  }\n  const { errors, result } = await getProfileFromName(\n    {\n      contracts,\n      gqlInstance,\n      _getAddr,\n      _getContentHash,\n      _getText,\n      resolverMulticallWrapper,\n      multicallWrapper\n    },\n    nameOrAddress,\n    options\n  );\n  if (errors)\n    throw new _utils_errors_mjs__WEBPACK_IMPORTED_MODULE_4__.ENSJSError({ data: result, errors });\n  return result;\n}\n\n\n\n//# sourceURL=webpack://dapp/./node_modules/@ensdomains/ensjs/dist/esm/functions/getProfile.mjs?");

/***/ }),

/***/ "./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   hexDecodeName: () => (/* binding */ hexDecodeName),\n/* harmony export */   hexEncodeName: () => (/* binding */ hexEncodeName)\n/* harmony export */ });\n/* harmony import */ var dns_packet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dns-packet */ \"./node_modules/dns-packet/index.js\");\n/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n// src/utils/hexEncodedName.ts\n\nvar hexEncodeName = (name) => `0x${dns_packet__WEBPACK_IMPORTED_MODULE_0__.name.encode(name).toString(\"hex\")}`;\nvar hexDecodeName = (hex) => dns_packet__WEBPACK_IMPORTED_MODULE_0__.name.decode(Buffer.from(hex.slice(2), \"hex\")).toString();\n\n\n\n//# sourceURL=webpack://dapp/./node_modules/@ensdomains/ensjs/dist/esm/utils/hexEncodedName.mjs?");

/***/ })

}]);